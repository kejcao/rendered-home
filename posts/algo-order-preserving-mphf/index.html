<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="/static/favicon.ico" type="image/x-icon">

  <link rel="stylesheet" type="text/css" href="/static/asciinema-player.css" />
  <script>MathJax = {tex: {inlineMath: [["$", "$"]], displayMath: [["$$", "$$"]], processEscapes: !1}}</script>
  <script type="text/javascript" id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

  <style>
    /* HLJS CODE HIGHLIGHTING */
    pre code.hljs {
      display: block;
      overflow-x: auto;
      padding: 1em
    }

    code.hljs {
      padding: 3px 5px
    }

    .hljs {
      background: #fefefe;
      color: #545454
    }

    .hljs-comment,
    .hljs-quote {
      color: #696969
    }

    .hljs-deletion,
    .hljs-name,
    .hljs-regexp,
    .hljs-selector-class,
    .hljs-selector-id,
    .hljs-tag,
    .hljs-template-variable,
    .hljs-variable {
      color: #d91e18
    }

    .hljs-attribute,
    .hljs-built_in,
    .hljs-link,
    .hljs-literal,
    .hljs-meta,
    .hljs-number,
    .hljs-params,
    .hljs-type {
      color: #aa5d00
    }

    .hljs-addition,
    .hljs-bullet,
    .hljs-string,
    .hljs-symbol {
      color: green
    }

    .hljs-section,
    .hljs-title {
      color: #007faa
    }

    .hljs-keyword,
    .hljs-selector-tag {
      color: #7928a1
    }

    .hljs-emphasis {
      font-style: italic
    }

    .hljs-strong {
      font-weight: 700
    }

    @media screen and (-ms-high-contrast:active) {

      .hljs-addition,
      .hljs-attribute,
      .hljs-built_in,
      .hljs-bullet,
      .hljs-comment,
      .hljs-link,
      .hljs-literal,
      .hljs-meta,
      .hljs-number,
      .hljs-params,
      .hljs-quote,
      .hljs-string,
      .hljs-symbol,
      .hljs-type {
        color: highlight
      }

      .hljs-keyword,
      .hljs-selector-tag {
        font-weight: 700
      }
    }

    /* HLJS CODE HIGHLIGHTING END */

    header div a::before {
      content: '';
      display: block;
      position: absolute;
      bottom: 14%;
      left: 0;
      width: 100%;
      height: 40%;
      transform: rotate(-1deg);
      background-color: orange;
      z-index: -1;
      opacity: .3;
      transition: opacity .2s ease-in-out;
    }

    header div a:hover::before {
      opacity: .8;
    }

    header div a {
      font-size: 1.8rem;
      display: inline-block;
      position: relative;
      text-decoration: none;
      color: inherit;
    }

    header {
      margin-top: 1rem;
    }

    header>div {
      text-align: center;
    }

    body {
      padding: 0 1rem;
      margin: 0 auto;
      color: #333333;
      max-width: 36rem;
      line-height: 1.55;
    }

    @media screen and (min-width:70ch) {
      main {
        word-break: auto-phrase;
        text-align: justify;
        text-justify: inter-character;
        hyphens: auto;
        hyphenate-limit-lines: 2;
      }
    }

    /* what follows are common sense defaults for all pages that inherit this layout.html */
    h1 {
      font-size: 2.25rem;
      line-height: 2.5rem;
      text-align: center;
    }

    ul,
    ol {
      text-align: left;
    }

    hr {
      margin: 32px 0;
    }

    li {
      margin: 4px 0;
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
      line-height: 1.2;
    }

    /* From https://developer.mozilla.org/en-US/docs/Web/HTML/Element/kbd */
    kbd>kbd {
      text-indent: 0;
      background-color: #eee;
      border-radius: 3px;
      border: 1px solid #b4b4b4;
      box-shadow:
        0 1px 1px rgba(0, 0, 0, 0.2),
        0 2px 0 0 rgba(255, 255, 255, 0.7) inset;
      color: #333;
      display: inline-block;
      font-size: 0.9em;
      font-weight: 700;
      line-height: 1;
      padding: 2px 4px;
      white-space: nowrap;
    }

    aside {
      border-left: 2px solid gray;
      border-radius: 2px;
      padding-left: 16px;
      margin: 0;
      margin-left: 32px;
    }

    code,
    pre {
      font-family: ui-monospace, 'Cascadia Code', 'Source Code Pro', Menlo, Consolas, 'DejaVu Sans Mono', monospace !important;
      overflow-y: hidden;
      hyphens: auto;
    }

    :not(pre)>code {
      font-size: 90%;
    }

    p+p {
      margin-top: 1.3em;
    }

    pre {
      border-radius: 8px;
      background-color: #f2f2f2;
      border: 1px solid #bfbfbf;
      padding: 4px 7px;
      overflow-x: auto;
      font-size: .8rem;
    }

    .img+pre {
      margin-top: 1rem;
    }

    pre:has(+.img) {
      margin-bottom: 1rem;
    }

    [id^="asciinema-cast-"] {
      max-width: 100%;
      border-radius: 8px;
      height: min-content;
      display: block;
      margin: 0 auto;
    }

    img {
      max-width: 100%;
      border-radius: 8px;
      height: auto;
      display: block;
      margin: 0 auto;
    }

    .hljs-meta.prompt_ {
      user-select: none;
    }


    summary {
      cursor: pointer;
      user-select: none;

      display: flex;
      align-items: center;
      justify-content: flex-end;
      margin-bottom: 20px;
    }

    details>summary::before {
      content: '>';
      font-weight: 700;
      padding-right: 10px;
    }

    details[open]>summary::before {
      content: '^';
    }

    summary::after {
      content: "";
      flex-grow: 1;
      height: 1px;
      background-color: #333;
      margin-left: 10px;
    }

    .code-preview.collapsed {
      position: relative;
    }

    .code-preview.collapsed pre {
      max-height: 300px;
      position: relative;
      overflow: hidden;
    }

    .code-preview.collapsed pre::after {
      content: "";
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 350px;
      background: linear-gradient(to top, rgba(0,0,0,0.3) 25%, rgba(0,0,0,0.12) 50%, rgba(0,0,0,0.0) 100%);
      pointer-events: none;
    }

    .code-preview .expand-btn {
      position: absolute;
      left: 50%;
      bottom: 10%;
      transform: translate(-50%, 10%);
      border: 1px solid black;
      border-radius: 4px;
      background: none;
      background-color: rgba(239, 239, 239, 0.7);
      padding: 8px;
      width: 180px;
    }

    .code-preview .expand-btn:hover {
      background-color: rgba(239, 239, 239);
    }

    .code-preview:not(.collapsed) .expand-btn {
      position: sticky;
      left: 50%;
      transform: translate(-50%);
    }
  </style><title>Generating Order-Preserving Minimal Perfect Hash Functions - Kevin Cao</title>
<meta name="description" content="A hash function is a function that maps a set of strings to integers between an
interval. If this function is injective, in other words the function produces no
hash collisions, then we call the hash function perfect. If furthermore the
function is bijective, then we call it a minimal perfect hash function,
sometimes abbreviated as MPHF. In computer science we sometimes refer to strings
as words." />
<style>
  h2,
  h3,
  h4,
  h5,
  h6 {
    margin-top: 32px;
    margin-bottom: 12px;
    margin-left: -28px;
    text-decoration: underline;
  }

  @media (min-width: 42rem) {
    pre {
      margin-left: -2rem;
      width: calc(100% + 4rem);
    }
  }

  @media (min-width: 42rem) {
    img {
      margin-left: -2rem;
	  max-width: calc(100% + 4rem) !important;
      width: calc(100% + 4rem);
    }
  }

  @media (min-width: 42rem) {
	[id^="asciinema-cast-"] {
      margin-left: -2rem;
	  max-width: calc(100% + 4rem) !important;
      width: calc(100% + 4rem);
    }
  }

  header>h1 {
    color: #333;
    padding: 0 1rem;
    text-align: center;
  }
</style></head>

<body><header><div>
      <a href="/">back to homepage</a>
    </div></header>

  <main><article>
  <header>
    <h1>Generating Order-Preserving Minimal Perfect Hash Functions</h1>
    <div style="padding-bottom:1rem; text-align:center"><time>Aug 7, 2024</time></div>
  </header>
  <p>A hash function is a function that maps a set of strings to integers between an interval. If this function is injective, in other words the function produces no hash collisions, then we call the hash function perfect. If furthermore the function is bijective, then we call it a minimal perfect hash function, sometimes abbreviated as MPHF. In computer science we sometimes refer to strings as words.</p><p>I spent an evening implementing the CHM algorithm from <a href="https://cmph.sourceforge.net/papers/chm92.pdf">a 1992 paper</a> in C++. I think the algorithm is quite interesting, so I&#039;ll share it here. Given a set of words $W$ the algorithm can generate minimal perfect hash functions of the form:</p><p>$$h(w) = g(f_1(w)) + g(f_2(w)) \bmod{|W|}. $$</p><p>At a high-level, the algorithm randomly generates functions $f_1,f_2$ that map words to integers. It then derives a function $g:\mathbb{Z}\to\mathbb{Z}$ such that $h$ becomes a bijection.</p><p>Specifically, we start by randomly generating two arrays $T_1,T_2$ of length $\max\{|w| : w \in W\}$ by populating each element with a random integer between $[0,n-1]$ where $n\geq |W|$ is a number we will discuss in detail later. Then, define,</p><p>$$\begin{aligned}
    f_1(w) &= \sum_{i=1}^{|w|} w[i]\cdot T_1[i] \bmod {n} \\
    f_2(w) &= \sum_{i=1}^{|w|} w[i]\cdot T_2[i] \bmod {n}
\end{aligned}$$</p><p>Now, think of the graph $G=(V,E)$ with $V=\{0,\dotsc,n-1\}$ and $E=\{(f_1(w),f_2(w)) : w\in W\}$. This undirected graph $G$ associates each edge with a word. Test whether or not the graph is acyclic, if not re-initialize $T_1,T_2$ to random values. Proceed until you find arrays $T_1,T_2$ such that the graph $G$ is acyclic.</p><p>That was the first part of the algorithm. In particular, the value $n$ influences the probability that we get an acyclic graph. For more details, and proofs on the probabilities, see the paper.</p><p>In the second part, Note how the value of the hash function can be written as $g(f_2(w)) = h(w) - g(f_1(w))$, which permits us to find a function $g$ such that $h$ is a bijection by simply performing DFS on each connected component of the graph. This is sure to work because the graph is acyclic. In more detail,</p><ul><li> Go through each vertex $v\in V$ and if $v$ has not been visited, set $g(v) = 0$ and run the procedure <code>DFS</code> on $v$.</li><li> In <code>DFS(v)</code>, mark $v$ as visited and for each neighbour $n\in N(v)$ if $n$ has not been visited, then set $g(n) = h((v,n)\in E) - g(v)$ and recursively run <code>DFS</code> on $n$. You can set $h(e)$ to whatever number you want the word associated with the edge $e$ to be hashed to.</li></ul><p>That was the algorithm. It consisted of two stages, first finding a suitable acyclic graph, then deducing a function $g$ that would make $h$ a bijection. Let&#039;s start our C++ implementation by defining $f$, which can be directly translated to C++.</p><pre ><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;w, <span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt; &amp;T)</span> </span>&lbrace;
    <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; w.<span class="hljs-built_in">size</span>(); ++i) &lbrace;
        s += T[i] * w[i];
    &rbrace;
    <span class="hljs-keyword">return</span> s;
&rbrace;</pre><p>In the global scope, start by setting up the devices we need to generate random numbers. I intended on practicing my C++23, hence the usage of <code>views</code> and <code>ranges</code>.</p><pre ><span class="hljs-keyword">namespace</span> rs = std::ranges;
<span class="hljs-keyword">using</span> std::views::transform;
<span class="hljs-keyword">using</span> std::views::iota;

std::random_device rd;
<span class="hljs-function">std::mt19937 <span class="hljs-title">gen</span><span class="hljs-params">(rd())</span></span>;</pre><p>In the main function, we read the words for the hash function to accept in a file. Then comes the main loop to find an acyclic graph. Usually, with properly chosen $n$, a suitable graph can be found in no more than 1â€“2 iterations. The graph is represented edge-wise as an adjacency list.</p><pre ><span class="hljs-function">std::ifstream <span class="hljs-title">ifs</span><span class="hljs-params">(<span class="hljs-string">&quot;words.in&quot;</span>)</span></span>;
std::string line;
std::vector&lt;std::string&gt; words;
<span class="hljs-keyword">while</span> (std::<span class="hljs-built_in">getline</span>(ifs, line)) &lbrace;
    words.<span class="hljs-built_in">push_back</span>(line);
&rbrace;

<span class="hljs-type">int</span> n = words.<span class="hljs-built_in">size</span>() * <span class="hljs-number">2</span>;
std::uniform_int_distribution&lt;&gt; <span class="hljs-built_in">dist</span>(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);

std::vector&lt;std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; graph;
std::vector&lt;<span class="hljs-type">int</span>&gt; T1, T2;
<span class="hljs-keyword">do</span> &lbrace;
    graph.<span class="hljs-built_in">clear</span>();
    T1.<span class="hljs-built_in">clear</span>();
    T2.<span class="hljs-built_in">clear</span>();

    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rs::<span class="hljs-built_in">max</span>(words | <span class="hljs-built_in">transform</span>(&amp;std::string::size)); ++i) &lbrace;
        T1.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">dist</span>(gen));
        T2.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">dist</span>(gen));
    &rbrace;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;w : words) &lbrace;
        graph.<span class="hljs-built_in">push_back</span>(&lbrace;<span class="hljs-built_in">f</span>(w, T1) % n, <span class="hljs-built_in">f</span>(w, T2) % n&rbrace;);
    &rbrace;
&rbrace; <span class="hljs-keyword">while</span> (<span class="hljs-built_in">has_cycle</span>(n, graph));</pre><p>The <code>has_cycle</code> function is implemented with a DSU, which is more suitable and natural for cycle detection than an algorithm such as DFS, especially if the graph is represented edge-wise.</p><pre ><span class="hljs-keyword">class</span> <span class="hljs-title class_">DSU</span> &lbrace;
    std::vector&lt;<span class="hljs-type">int</span>&gt; parent, rank;
    <span class="hljs-type">int</span> n;

<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">DSU</span>(<span class="hljs-type">int</span> n) : n&lbrace;n&rbrace; &lbrace;
        parent = rs::to&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;(<span class="hljs-built_in">iota</span>(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>));
        rank = std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>);
    &rbrace;

    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&lbrace;
        <span class="hljs-keyword">if</span> (u == parent[u]) <span class="hljs-keyword">return</span> u;
        <span class="hljs-keyword">return</span> parent[u] = <span class="hljs-built_in">find</span>(parent[u]);
    &rbrace;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&lbrace;
        u = <span class="hljs-built_in">find</span>(u);
        v = <span class="hljs-built_in">find</span>(v);
        <span class="hljs-keyword">if</span> (u != v) &lbrace;
            <span class="hljs-keyword">if</span> (size[u] &lt; size[v])
                std::<span class="hljs-built_in">swap</span>(u, v);
            parent[v] = u;
            size[u] += size[v];
        &rbrace;
    &rbrace;
&rbrace;;

<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">has_cycle</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;graph)</span> </span>&lbrace;
    <span class="hljs-function">DSU <span class="hljs-title">dsu</span><span class="hljs-params">(n)</span></span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [u, v] : graph) &lbrace;
        <span class="hljs-keyword">if</span> (dsu.<span class="hljs-built_in">find</span>(u) == dsu.<span class="hljs-built_in">find</span>(v)) &lbrace;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        &rbrace;
        dsu.<span class="hljs-built_in">unite</span>(u, v);
    &rbrace;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
&rbrace;</pre><p>Now, we deduce the value of the function $g$.</p><pre ><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">deduce_g</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;graph)</span> </span>&lbrace;
    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">g</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;
    std::set&lt;<span class="hljs-type">int</span>&gt; visited;

    <span class="hljs-keyword">auto</span> dfs = [&amp;](<span class="hljs-keyword">auto</span> &amp;self, <span class="hljs-type">int</span> v) -&gt; <span class="hljs-type">void</span> &lbrace;
        visited.<span class="hljs-built_in">insert</span>(v);
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; graph.<span class="hljs-built_in">size</span>(); ++i) &lbrace;
            <span class="hljs-keyword">auto</span> [a, b] = graph[i];
            <span class="hljs-keyword">if</span> (b == v) &lbrace;
                std::<span class="hljs-built_in">swap</span>(a, b);
            &rbrace;
            <span class="hljs-keyword">if</span> (a == v &amp;&amp; !visited.<span class="hljs-built_in">contains</span>(b)) &lbrace;
                <span class="hljs-comment">// CPP promotes dividend into unsigned integer,</span>
                <span class="hljs-comment">// causing me hours of pain.</span>
                <span class="hljs-comment">// g[b] = (i - g[a]) % graph.size();</span>

                g[b] = i - g[a]; <span class="hljs-comment">// Just use this, we do modulo later</span>
                <span class="hljs-built_in">self</span>(self, b);
            &rbrace;
        &rbrace;
    &rbrace;;

    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &lbrace;
        <span class="hljs-keyword">if</span> (!visited.<span class="hljs-built_in">contains</span>(i)) &lbrace;
            g[i] = <span class="hljs-number">0</span>;
            <span class="hljs-built_in">dfs</span>(dfs, i);
        &rbrace;
    &rbrace;
    <span class="hljs-keyword">return</span> g;
&rbrace;</pre><p>Fun fact, I spent hours debugging my code. Turns out, C++ automatically promotes the dividend of the modulo operation into an unsigned integer because <code>graph.size()</code> was unsigned. Hence, if <code>i-g[a]</code> was a negative integer, the sign was just dropped unceremoniously.</p><pre ><span class="hljs-keyword">auto</span> g = <span class="hljs-built_in">deduce_g</span>(n, graph);
<span class="hljs-built_in">emit_python</span>(words.<span class="hljs-built_in">size</span>(), T1, T2, g);

<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; words.<span class="hljs-built_in">size</span>(); ++i) &lbrace;
    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> w = words[i];
    <span class="hljs-built_in">assert</span>((g[<span class="hljs-built_in">f</span>(w, T1) % n] + g[<span class="hljs-built_in">f</span>(w, T2) % n]) % graph.<span class="hljs-built_in">size</span>() == i);
&rbrace;</pre><p>In the final step here, we can use the arrays $T_1,T_2$ and the function $g$ however we like. You can confirm that it is indeed a minimal perfect hash function or we can emit the hash function into a different language to use. I won&#039;t show the <code>emit_python</code> function here, it&#039;s straightforward but pretty messy.</p><p>The CHM algorithm is definitely not optimal; there exists better MPHF generation algorithms such as the <a href="https://cmph.sourceforge.net/chd.html">CHD algorithm</a>.</p>
</article></main></body>

</html>