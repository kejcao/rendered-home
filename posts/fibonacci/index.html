<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="/static/favicon.ico" type="image/x-icon">

  <link rel="stylesheet" type="text/css" href="/static/asciinema-player.css" />
  <script>MathJax = {tex: {inlineMath: [["$", "$"]], displayMath: [["$$", "$$"]], processEscapes: !1}}</script>
  <script type="text/javascript" id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

  <style>
    /* HLJS CODE HIGHLIGHTING */
    pre code.hljs {
      display: block;
      overflow-x: auto;
      padding: 1em
    }

    code.hljs {
      padding: 3px 5px
    }

    .hljs {
      background: #fefefe;
      color: #545454
    }

    .hljs-comment,
    .hljs-quote {
      color: #696969
    }

    .hljs-deletion,
    .hljs-name,
    .hljs-regexp,
    .hljs-selector-class,
    .hljs-selector-id,
    .hljs-tag,
    .hljs-template-variable,
    .hljs-variable {
      color: #d91e18
    }

    .hljs-attribute,
    .hljs-built_in,
    .hljs-link,
    .hljs-literal,
    .hljs-meta,
    .hljs-number,
    .hljs-params,
    .hljs-type {
      color: #aa5d00
    }

    .hljs-addition,
    .hljs-bullet,
    .hljs-string,
    .hljs-symbol {
      color: green
    }

    .hljs-section,
    .hljs-title {
      color: #007faa
    }

    .hljs-keyword,
    .hljs-selector-tag {
      color: #7928a1
    }

    .hljs-emphasis {
      font-style: italic
    }

    .hljs-strong {
      font-weight: 700
    }

    @media screen and (-ms-high-contrast:active) {

      .hljs-addition,
      .hljs-attribute,
      .hljs-built_in,
      .hljs-bullet,
      .hljs-comment,
      .hljs-link,
      .hljs-literal,
      .hljs-meta,
      .hljs-number,
      .hljs-params,
      .hljs-quote,
      .hljs-string,
      .hljs-symbol,
      .hljs-type {
        color: highlight
      }

      .hljs-keyword,
      .hljs-selector-tag {
        font-weight: 700
      }
    }

    /* HLJS CODE HIGHLIGHTING END */

    header div a::before {
      content: '';
      display: block;
      position: absolute;
      bottom: 14%;
      left: 0;
      width: 100%;
      height: 40%;
      transform: rotate(-1deg);
      background-color: orange;
      z-index: -1;
      opacity: .3;
      transition: opacity .2s ease-in-out;
    }

    header div a:hover::before {
      opacity: .8;
    }

    header div a {
      font-size: 1.8rem;
      display: inline-block;
      position: relative;
      text-decoration: none;
      color: inherit;
    }

    header {
      margin-top: 1rem;
    }

    header>div {
      text-align: center;
    }

    body {
      padding: 0 1rem;
      margin: 0 auto;
      color: #333333;
      max-width: 36rem;
      line-height: 1.55;
    }

    @media screen and (min-width:70ch) {
      main {
        word-break: auto-phrase;
        text-align: justify;
        text-justify: inter-character;
        hyphens: auto;
        hyphenate-limit-lines: 2;
      }
    }

    /* what follows are common sense defaults for all pages that inherit this layout.html */
    h1 {
      font-size: 2.25rem;
      line-height: 2.5rem;
      text-align: center;
    }

    ul,
    ol {
      text-align: left;
    }

    hr {
      margin: 32px 0;
    }

    li {
      margin: 4px 0;
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
      line-height: 1.2;
    }

    /* From https://developer.mozilla.org/en-US/docs/Web/HTML/Element/kbd */
    kbd>kbd {
      text-indent: 0;
      background-color: #eee;
      border-radius: 3px;
      border: 1px solid #b4b4b4;
      box-shadow:
        0 1px 1px rgba(0, 0, 0, 0.2),
        0 2px 0 0 rgba(255, 255, 255, 0.7) inset;
      color: #333;
      display: inline-block;
      font-size: 0.9em;
      font-weight: 700;
      line-height: 1;
      padding: 2px 4px;
      white-space: nowrap;
    }

    aside {
      border-left: 2px solid gray;
      border-radius: 2px;
      padding-left: 16px;
      margin: 0;
      margin-left: 32px;
    }

    code,
    pre {
      font-family: ui-monospace, 'Cascadia Code', 'Source Code Pro', Menlo, Consolas, 'DejaVu Sans Mono', monospace !important;
      overflow-y: hidden;
      hyphens: auto;
    }

    :not(pre)>code {
      font-size: 90%;
    }

    p+p {
      margin-top: 1.3em;
    }

    pre {
      border-radius: 8px;
      background-color: #fcfcfc;
      border: 1px solid #f2f2f2;
      padding: 4px 7px;
      overflow-x: auto;
      font-size: .8rem;
    }

    .img+pre {
      margin-top: 1rem;
    }

    pre:has(+.img) {
      margin-bottom: 1rem;
    }

    [id^="asciinema-cast-"] {
      max-width: 100%;
      border-radius: 8px;
      height: min-content;
      display: block;
      margin: 0 auto;
    }

    img {
      max-width: 100%;
      border-radius: 8px;
      height: auto;
      display: block;
      margin: 0 auto;
    }

    .hljs-meta.prompt_ {
      user-select: none;
    }


    summary {
      cursor: pointer;
      user-select: none;

      display: flex;
      align-items: center;
      justify-content: flex-end;
      margin-bottom: 20px;
    }

    details>summary::before {
      content: '>';
      font-weight: 700;
      padding-right: 10px;
    }

    details[open]>summary::before {
      content: '^';
    }

    summary::after {
      content: "";
      flex-grow: 1;
      height: 1px;
      background-color: #333;
      margin-left: 10px;
    }

    .code-preview.collapsed {
      position: relative;
    }

    .code-preview.collapsed pre {
      max-height: 300px;
      position: relative;
    }

    .code-preview.collapsed pre::after {
      content: "";
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 300px;
      background: linear-gradient(to bottom, transparent 25%, 75%, gray);
      pointer-events: none;
    }

    .code-preview .expand-btn {
      position: absolute;
      left: 50%;
      bottom: 10%;
      transform: translate(-50%, 10%);
      border: 1px solid black;
      border-radius: 4px;
      background: none;
      background-color: rgba(239, 239, 239, 0.7);
      padding: 6px;
      width: 120px;
    }

    .code-preview .expand-btn:hover {
      background-color: rgba(239, 239, 239);
    }

    .code-preview:not(.collapsed) .expand-btn {
      position: sticky;
      left: 50%;
      transform: translate(-50%);
    }
  </style><title>Calculating the 1 Billionth Fibonacci Number in 8 Seconds - Kevin Cao</title>
<meta name="description" content="The Fibonacci sequence was popularized in Western Europe by Leonardo of Pisa,
where he used it to model rabbit population growth in his 1202 book Liber Abaci.
However, the sequence was already known by Indian mathematicians as early as 200
BC, when it was used to enumerate possible patterns of Sanskrit poetry." />
<style>
  h2,
  h3,
  h4,
  h5,
  h6 {
    margin-top: 32px;
    margin-bottom: 12px;
    margin-left: -28px;
    text-decoration: underline;
  }

  @media (min-width: 42rem) {
    pre {
      margin-left: -2rem;
      width: calc(100% + 4rem);
    }
  }

  @media (min-width: 42rem) {
    img {
      margin-left: -2rem;
	  max-width: calc(100% + 4rem) !important;
      width: calc(100% + 4rem);
    }
  }

  @media (min-width: 42rem) {
	[id^="asciinema-cast-"] {
      margin-left: -2rem;
	  max-width: calc(100% + 4rem) !important;
      width: calc(100% + 4rem);
    }
  }

  header>h1 {
    color: #333;
    padding: 0 1rem;
    text-align: center;
  }
</style></head>

<body><header><div>
      <a href="/">back to homepage</a>
    </div></header>

  <main><article>
  <header>
    <h1>Calculating the 1 Billionth Fibonacci Number in 8 Seconds</h1>
    <div style="padding-bottom:1rem; text-align:center"><time>Jun 9, 2024</time></div>
  </header>
  <p>The Fibonacci sequence was popularized in Western Europe by Leonardo of Pisa, where he used it to model rabbit population growth in his 1202 book <em>Liber Abaci</em>. However, the sequence was already known by Indian mathematicians as early as 200 BC, when it was used to enumerate possible patterns of Sanskrit poetry.</p><p>The Fibonacci sequence is defined by a simple recurrence, where the $n$th Fibonacci number is $F_n = F_{n-1} + F_{n-2}$. The function which implements this recurrence in code is often used to demonstrate the dynamic programming technique called memoization, which can be applied to the function resulting in dramatic speedups. A straightforward implementation of this function in Python is trivial:</p><pre ><span class="hljs-keyword">import</span> functools

<span class="hljs-meta">@functools.cache</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">fib</span>(<span class="hljs-params">n</span>):
    <span class="hljs-keyword">match</span> n:
        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> fib(n-<span class="hljs-number">1</span>) + fib(n-<span class="hljs-number">2</span>)</pre><p>Looking at this recursive function and the corresponding recurrence, we notice that it&#039;s a waste of memory to memoize $O(n)$ numbers when it&#039;s only necessary to remember the previous two Fibonacci numbers to calculate the next one. An iterative approach is not only faster than recursion, but also much more memory efficient.</p><pre ><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib</span>(<span class="hljs-params">n</span>):
    a, b = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>
    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
        a, b = b, a + b
    <span class="hljs-keyword">return</span> a</pre><p>It will be useful for us to view the above function in a certain way. The code inside the for loop can be thought of as applying a linear map $T : \mathbb{R}^2 \to \mathbb{R}^2$ to the two variables $a$ and $b$, transforming them into two new numbers. This linear map is defined with $Tv = (v_2, v_1+v_2)$. An example of this in code may help with your understanding, where we separate out and define $T$ explicitly:</p><pre ><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib</span>(<span class="hljs-params">n</span>):
    T = <span class="hljs-keyword">lambda</span> v: (v[<span class="hljs-number">1</span>], v[<span class="hljs-number">0</span>] + v[<span class="hljs-number">1</span>])
    v = (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)
    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
        v = T(v)
    <span class="hljs-keyword">return</span> v[<span class="hljs-number">0</span>]</pre><p>This is useful because we can now find the matrix representation of this linear map $T$ by finding the values of $T$ for the basis vectors of $\mathbb{R}^2$, the domain of $T$.</p><p>$$\begin{aligned}
    T(1,0) &= (0,1+0) = (0,1) \\
    T(0,1) &= (1,0+1) = (1,1)
\end{aligned}
\implies
Tv = \begin{pmatrix}
    0 & 1 \\
    1 & 1 
\end{pmatrix}v$$</p><p>Confusingly, we can also construct another map $Tv = (v_1 + v_2, v_1)$ which is almost the same as the previous map but swaps the position. This results in a slightly different matrix, which seems to be more standard in literature than the first for some reason.</p><p>$$\begin{aligned}
    T(1,0) &= (1+0,1) = (1,1) \\
    T(0,1) &= (0+1,0) = (1,0)
\end{aligned}
\implies
Tv = \begin{pmatrix}
    1 & 1 \\
    1 & 0 
\end{pmatrix}v$$</p><p>The matrix for $T$, containing all ones except for the bottom-right corner which is a zero, is a very special matrix called the <a href="https://mathworld.wolfram.com/FibonacciQ-Matrix.html">Fibonacci $Q$-matrix</a>. Note that multiplying the matrix $Q^k$ by the initial vector containing the first two Fibonacci numbers $(F_1,F_0) = (1,0)$ simply yields $Q^k (1,0)^T = (F_{n+1},F_n)^T$.</p><p>The corresponding code using this new map $T$ would look like this:</p><pre ><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib</span>(<span class="hljs-params">n</span>):
    T = <span class="hljs-keyword">lambda</span> v: (v[<span class="hljs-number">0</span>] + v[<span class="hljs-number">1</span>], v[<span class="hljs-number">0</span>])
    v = (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)
    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
        v = T(v)
    <span class="hljs-keyword">return</span> v[<span class="hljs-number">1</span>]</pre><p>In fact, we can directly exponentiate the $Q$-matrix to get the $n$th Fibonacci number. We have this equation:</p><p>$$\begin{gathered}Q^k = \begin{pmatrix}
    1 & 1 \\
    1 & 0 
\end{pmatrix}^k = \begin{pmatrix}
    F_{n+1} & F_n \\
    F_n & F_{n-1}
\end{pmatrix}\end{gathered}$$</p><p>Therefore, a faster algorithm to find the $F_n$ involves calculating the $n$th power of $Q$. This can be computed in $O(\log n)$ time using binary exponentiation.</p><pre ><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np

<span class="hljs-keyword">def</span> <span class="hljs-title function_">fib</span>(<span class="hljs-params">n</span>):
    Q = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]], dtype=<span class="hljs-built_in">object</span>)
    <span class="hljs-keyword">return</span> np.linalg.matrix_power(Q, n)[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]</pre><p>It seems wasteful to exponentiate the entire 2x2 matrix when we only need one of the entries. Can we avoid the unnecessary computation? Because matrix multiplication is associative, we can think of $Q^{2n}$ in two ways: $Q^{(2n)}$ and $(Q^n)^2$. This gives us the following equality:</p><p>$$\begin{pmatrix}
    F_{2n+1} & F_{2n} \\
    F_{2n} & F_{2n-1}
\end{pmatrix} = Q^{2n} =
\begin{pmatrix}
    F_{n+1} & F_{n} \\
    F_{n} & F_{n-1}
\end{pmatrix}^2$$</p><p>By explicitly multiplying the matrix on the right-hand side by itself and matching its entries with those of the matrix on the left-hand side, we obtain a couple identities involving the Fibonacci numbers.</p><p>$$\begin{aligned}
    F_{2n+1} &= F_{n+1}^2 + F_n^2 \\
    F_{2n} &= F_{n+1}F_n + F_nF_{n-1}
\end{aligned}$$</p><p>Firstly, note that,</p><p>$$\begin{aligned}
    &\hphantom{\implies}\,\, F_{n} = F_{n-1} + F_{n-2} \\
    &\implies F_{n+1} = F_n + F_{n-1} \\
    &\implies F_{n+1} - F_n = F_{n-1}
\end{aligned}$$</p><p>Therefore, we can rewrite the second identity, replacing $F_{n-1}$.</p><p>$$\begin{aligned}
    F_{2n} &= F_{n+1}F_n + F_nF_{n-1} \\
    &= F_n (F_{n+1} + F_{n-1}) \\
    &= F_n (F_{n+1} + (F_{n+1} - F_n)) \\
    &= F_n (2F_{n+1} - F_n)
\end{aligned}$$</p><p>With these two identities, we can express $F_{2n}$ and $F_{2n+1}$ solely in terms of $F_n$ and $F_{n+1}$. Let&#039;s abbreviate these Fibonacci numbers with single-letter variables.</p><p>$$\begin{gathered}a,b := F_n, F_{n+1} \\
    c := F_{2n} = a (2b - a) \\
    d := F_{2n+1} = b^2 + a^2\end{gathered}$$</p><p>Given this, it&#039;s easy to derive concise and fast code to calculate the $n$th Fibonacci number. In the Python code below, I use GMP to speedup integer arithmetic.</p><pre ><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> mpz

<span class="hljs-keyword">def</span> <span class="hljs-title function_">fib</span>(<span class="hljs-params">n</span>):
    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span> (mpz(<span class="hljs-number">0</span>), mpz(<span class="hljs-number">1</span>))

    (a, b) = fib(n // <span class="hljs-number">2</span>)
    c = a * (<span class="hljs-number">2</span>*b - a)
    d = a**<span class="hljs-number">2</span> + b**<span class="hljs-number">2</span>

    <span class="hljs-keyword">if</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span> (c, d)
    <span class="hljs-keyword">return</span> (d, c + d)</pre><p>Running the code,</p><pre >n = fib(<span class="hljs-number">1_000_000_000</span>)[<span class="hljs-number">0</span>]
<span class="hljs-built_in">print</span>(n, file=<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;out&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>))</pre><p>It takes 8.6 seconds to calculate the 1 billionth Fibonacci number and 38.4 seconds for the I/O. The result is a 208,987,641 digit number stored in a 200 MB file. I verified the digit count, it matches estimates I received from calculating the log10 of Binet&#039;s formula.</p><p>Speaking of Binet&#039;s formula, how does one derive that? Well, there are two ways: Examining the eigendecomposition of the $Q$-matrix or using generating functions. Rather than explaining them here, for more information see the <a href="https://en.wikipedia.org/wiki/Fibonacci_sequence#Matrix_form">Wikipedia article</a> on the Fibonacci sequence.</p><p>Note that many of the things discussed in this blog post is generalizable to linear recurrences in general.</p>
</article></main></body>

</html>